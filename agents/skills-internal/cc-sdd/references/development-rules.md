# cc-sdd 開発ルール詳細

このドキュメントでは、cc-sdd を使用する際の7つの開発ルールを詳しく説明します。

## ルール概要

1. Steeringの活用
2. 3段階承認ワークフロー
3. 承認必須
4. フェーズスキップ禁止
5. タスクステータス更新
6. Steeringの最新化
7. スペック準拠確認

---

## ルール 1: Steeringの活用

### 原則

大規模開発の前に `/kiro:steering` を実行する（新機能の場合はオプショナル）

### 詳細説明

**Steering** はプロジェクト全体のガイダンスを提供するため、開発の方向性を明確にします。

**実行すべき時**:

- プロジェクト初期設定時
- アーキテクチャの大幅な変更前
- 新しい技術スタックの導入前
- 重要なプロダクト方向性の変更時

**スキップ可能な時**:

- 小規模な新機能の追加
- 既存パターンに従う開発
- 実験的な機能の試作

### 理由

Steeringがないと：

- プロジェクトの基準が不明確
- 技術的決定が一貫しない
- コード品質がばらつく
- 新しいメンバーのオンボーディングが困難

### 実践例

**良い例**:

```
# 新規プロジェクト開始時
/kiro:steering

# 新機能の追加（ステアリング既存）
/kiro:spec-init ユーザープロフィール機能の追加
```

**悪い例**:

```
# ステアリングなしでいきなり実装
/kiro:spec-init ユーザープロフィール機能の追加
# → プロジェクトの基準が不明確なまま開発
```

---

## ルール 2: 3段階承認ワークフロー

### 原則

Requirements → Design → Tasks → Implementation の順序を守る

### 詳細説明

各段階は前の段階の成果物に基づきます：

1. **Requirements（要件定義）**
   - 何を作るのかを明確化
   - EARS形式で受入基準を定義

2. **Design（技術設計）**
   - どのように作るのかを設計
   - アーキテクチャと技術選択を文書化

3. **Tasks（実装タスク）**
   - 作業を管理可能な単位に分割
   - 実装の手順を明確化

4. **Implementation（実装）**
   - タスクに従って実装
   - 品質を保証しながら進める

### 理由

この順序により：

- 各段階で焦点を絞れる
- 早期に問題を発見できる
- 手戻りを最小化できる
- 品質を段階的に保証できる

### 実践例

**良い例**:

```
# 1. 要件定義
/kiro:spec-requirements user-auth
# レビュー → 承認

# 2. 設計
/kiro:spec-design user-auth -y
# レビュー → 承認

# 3. タスク
/kiro:spec-tasks user-auth -y
# レビュー → 承認

# 4. 実装開始
```

**悪い例**:

```
# 要件を飛ばしていきなり設計
/kiro:spec-design user-auth
# → 要件が不明確なまま設計が進む
```

---

## ルール 3: 承認必須

### 原則

各フェーズで人間のレビューが必要（対話的プロンプトまたは手動）

### 詳細説明

**承認が必要な理由**:

- AIの生成物は常に完璧ではない
- ビジネス要件の理解確認
- 技術的決定の妥当性検証
- プロジェクト固有のコンテキスト反映

**承認方法**:

1. **対話的承認**

   ```
   /kiro:spec-design user-auth -y
   # -y フラグで前フェーズを自動承認
   ```

2. **手動承認**

   ```
   # spec.json を手動で編集
   "approvals": {
     "requirements": {
       "generated": true,
       "approved": true  # ← 手動で true に変更
     }
   }
   ```

### レビューポイント

#### Requirements承認時

- [ ] 要件は明確で理解可能か
- [ ] 受入基準は測定可能か
- [ ] すべての機能がカバーされているか
- [ ] EARS形式が正しく使われているか
- [ ] ビジネス価値が明確か

#### Design承認時

- [ ] アーキテクチャは適切か
- [ ] 技術選択は正当化されているか
- [ ] すべての要件が設計でカバーされているか
- [ ] リスクは適切に対処されているか
- [ ] パフォーマンスとセキュリティは考慮されているか

#### Tasks承認時

- [ ] タスクサイズは適切か（1-3時間）
- [ ] すべての要件がタスクでカバーされているか
- [ ] タスクの依存関係は正しいか
- [ ] 技術選択は設計と一致しているか
- [ ] 実装可能な粒度か

### 実践例

**良い例**:

```
# 要件を生成
/kiro:spec-requirements user-auth

# 内容をレビュー
# - 要件1.1: 明確 ✓
# - 要件1.2: 曖昧、修正必要 ✗

# 修正を要求して再生成
/kiro:spec-requirements user-auth
# 修正内容を反映

# 再度レビュー → 承認
/kiro:spec-design user-auth -y
```

**悪い例**:

```
# 生成物をレビューせずに次へ進む
/kiro:spec-requirements user-auth
/kiro:spec-design user-auth -y
/kiro:spec-tasks user-auth -y
# → 要件の問題が後から発覚し大幅な手戻り
```

---

## ルール 4: フェーズスキップ禁止

### 原則

Design には承認済み Requirements が必要、Tasks には承認済み Design が必要

### 詳細説明

**依存関係**:

```
Requirements (承認済み)
    ↓
Design (承認済み)
    ↓
Tasks (承認済み)
    ↓
Implementation
```

各フェーズは前フェーズの成果物を入力として使用します。

### 理由

フェーズをスキップすると：

- 設計が要件と乖離
- タスクが設計と不整合
- 実装が要件を満たさない
- 手戻りが大きくなる

### 実践例

**良い例**:

```
# 要件 → 設計 → タスク の順序
/kiro:spec-requirements user-auth  # 承認
/kiro:spec-design user-auth -y     # 承認
/kiro:spec-tasks user-auth -y      # 承認
```

**悪い例**:

```
# 要件をスキップして設計
/kiro:spec-init user-auth
/kiro:spec-design user-auth
# → エラー: Requirements must be approved first
```

---

## ルール 5: タスクステータス更新

### 原則

作業時にタスクを完了としてマーク

### 詳細説明

**更新タイミング**:

- タスク開始時: 進行中にマーク（オプショナル）
- タスク完了時: 完了にマーク（必須）
- ブロック時: 問題を記録

**更新方法**:

tasks.md のチェックボックスを更新：

```markdown
- [x] 1. プロジェクト基盤のセットアップ # 完了
- [ ] 2. 認証システムの構築 # 未完了
- [ ] 2.1 コア認証機能の実装 # 未完了
```

### 理由

ステータス更新により：

- 進捗を正確に把握できる
- `/kiro:spec-status` で状況を可視化できる
- チーム全体で進捗を共有できる
- 次のタスクを明確にできる

### 実践例

**良い例**:

```
# タスク 1 を実装
# ... 実装完了 ...

# tasks.md を更新
- [x] 1. プロジェクト基盤のセットアップ

# 進捗確認
/kiro:spec-status user-auth
# → タスク完了: 1/10 (10%)
```

**悪い例**:

```
# 複数タスクを実装しても更新しない
# ... タスク 1, 2, 3 を実装 ...

# 進捗確認
/kiro:spec-status user-auth
# → タスク完了: 0/10 (0%)  # 実際の進捗が反映されない
```

---

## ルール 6: Steeringの最新化

### 原則

重要な変更後に `/kiro:steering` を実行

### 詳細説明

**更新すべき時**:

- 新しい技術の導入後
- アーキテクチャパターンの変更後
- プロダクト方向性の変更後
- 依存関係の大幅な更新後
- 開発プロセスの変更後

**更新内容**:

- `product.md`: 新機能、削除された機能、変更された価値提案
- `tech.md`: 新しい依存関係、技術スタックの変更、環境変数
- `structure.md`: ディレクトリ構造の変更、命名規則の更新

### 理由

Steeringが古いと：

- AIが古い情報で判断
- 新しいパターンが反映されない
- 一貫性が失われる
- 新メンバーが混乱

### 実践例

**良い例**:

```
# Next.js 14 → 15 にアップグレード
npm install next@15

# Steeringを更新
/kiro:steering
# → tech.md が自動的に更新される
```

**悪い例**:

```
# 技術スタックを大幅に変更
# GraphQL を追加、Redux を削除

# Steeringを更新しない
# → 新しい仕様で古いパターン（Redux）が参照される
```

---

## ルール 7: スペック準拠確認

### 原則

`/kiro:spec-status` で整合性を検証

### 詳細説明

**確認タイミング**:

- 各フェーズ完了後
- 実装の中間地点
- 最終的な完了前
- 問題が発生した時

**確認内容**:

- フェーズステータス
- 要件カバレッジ
- タスク完了率
- ステアリング整合性
- 推奨事項

### 理由

定期的な確認により：

- 問題を早期発見
- 進捗を可視化
- 次のアクションを明確化
- 品質を保証

### 実践例

**良い例**:

```
# 実装中に定期的に確認
/kiro:spec-status user-auth

# 出力例:
# Phase: implementation-ready
# Tasks: 5/10 completed (50%)
# Requirements coverage: 100%
# Next: Complete task 2.2
```

**悪い例**:

```
# 最後まで確認しない
# ... すべてのタスクを実装 ...

# 最後に確認
/kiro:spec-status user-auth
# → 要件カバレッジ: 70%  # 見落としを発見
# → 大幅な手戻り
```

---

## ルールの相互関係

これらの7つのルールは相互に関連しています：

```
Rule 1: Steering活用
    ↓
Rule 2-4: 段階的ワークフローと承認
    ↓
Rule 5: タスク進捗の追跡
    ↓
Rule 6-7: 品質保証と整合性確認
```

### 実践的なワークフロー例

```bash
# Rule 1: Steeringを作成
/kiro:steering

# Rule 2: 段階的ワークフロー開始
/kiro:spec-init ユーザー認証機能

# Rule 3 & 4: 承認を経て進行
/kiro:spec-requirements user-auth     # 生成
# レビュー → 承認

/kiro:spec-design user-auth -y        # 生成
# レビュー → 承認

/kiro:spec-tasks user-auth -y         # 生成
# レビュー → 承認

# 実装開始
# Rule 5: タスクステータスを更新
# タスク 1 完了 → チェック
# タスク 2 完了 → チェック

# Rule 7: 進捗確認
/kiro:spec-status user-auth

# 技術変更発生
npm install new-library

# Rule 6: Steeringを更新
/kiro:steering

# Rule 7: 最終確認
/kiro:spec-status user-auth
```

---

## まとめ

これら7つの開発ルールは、cc-sdd の品質と一貫性を保証するための基盤です。各ルールを理解し、実践することで、効率的で高品質な開発プロセスを実現できます。

**重要なポイント**:

1. Steeringでプロジェクトの基盤を確立
2. 段階的なワークフローで焦点を絞る
3. 各フェーズで必ず承認を得る
4. 順序を守り、スキップしない
5. 進捗を可視化し続ける
6. プロジェクトの変化を反映し続ける
7. 定期的に整合性を確認
